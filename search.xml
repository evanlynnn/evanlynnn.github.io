<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CSAPP实验：Bomb Lab</title>
      <link href="/2021/01/08/bomb-lab/"/>
      <url>/2021/01/08/bomb-lab/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前期准备"><a href="#一、前期准备" class="headerlink" title="一、前期准备"></a>一、前期准备</h2><ol><li>阅读 README-bomblab.txt 文档</li><li>阅读bomblab.pdf</li><li>解压文件: linux-x86-64 binary bomb.tar<br>由于原文件名有空格，无法使用tar -xvf命令，需对其改名<br>先将文件名改为bomb64.tar，然后在终端输入一下命令：<pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">tar</span> -xvf bomb64.tar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>解压完成后会在当前目录生成名为bomb的子目录</li><li>阅读bomb目录文件<br>在bomb目录下共有三个文件：<br>README<br>bomb.c  bomb的部分代码<br>bomb    bomb的可执行文件</li></ol><hr><p>打开README，发现其中的内容为：This is an x86-64 bomb for self-study students.<br>这是炸弹的学生信息<br>打开bomb.c，寻找main函数的关键信息</p><pre class="line-numbers language-C"><code class="language-C">printf("Welcome to my fiendish little bomb. You have 6 phases with\n");printf("which to blow yourself up. Have a nice day!\n");input = read_line();             /* Get input                   */phase_1(input);                  /* Run the phase               */phase_defused();                 /* Drat!  They figured it out!* Let me know how they did it. */printf("Phase 1 defused. How about the next one?\n");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过代码，我们发现要拆解炸弹，就是给出每个阶段对应的一串输入。代码中不包含各阶段的处理函数，那么接下来就需要对bomb进行反汇编。</p><ol start="5"><li>使用objdump对bomb反汇编<br>(1) 打印bomb的各函数和全局变量，并存储在bombTable.txt中<pre class="line-numbers language-bash"><code class="language-bash">objdump -t bomb<span class="token operator">></span>bombTable.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>(2) 对bomb反汇编，生成汇编代码，并保存在bomb.asm</p><pre class="line-numbers language-bash"><code class="language-bash">objdump -d bomb<span class="token operator">></span>bomb.asm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>前期准备完成，接下来开始分析汇编代码。</p><h2 id="二、phase-1"><a href="#二、phase-1" class="headerlink" title="二、phase_1"></a>二、phase_1</h2><h3 id="汇编代码及分析"><a href="#汇编代码及分析" class="headerlink" title="汇编代码及分析"></a>汇编代码及分析</h3><pre class="line-numbers language-assembly"><code class="language-assembly">0000000000400ee0 <phase_1>:  400ee0:    48 83 ec 08              sub    $0x8,%rsp # 分配栈帧空间  400ee4:    be 00 24 40 00           mov    $0x402400,%esi # 将0x402400保存在寄存器esi中  400ee9:    e8 4a 04 00 00           callq  401338 <strings_not_equal> # 调用函数<strings_not_equal>  400eee:    85 c0                    test   %eax,%eax # 比较函数的返回值  400ef0:    74 05                    je     400ef7 <phase_1+0x17> # 如果返回值为0，跳到指令400ef7  400ef2:    e8 43 05 00 00           callq  40143a <explode_bomb> # 引爆炸弹  400ef7:    48 83 c4 08              add    $0x8,%rsp # 回收栈帧空间  400efb:    c3                       retq   # 函数返回<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一阶段的函数参数为一个字符串，存储在寄存器%edi中。<br>然后，将0x402400存入寄存器%esi中，<br>再调用 <strong>strings_not_equal</strong> 函数比较寄存器%edi和%esi中的两个字符串。</p><h3 id="查看地址0x402400的内容"><a href="#查看地址0x402400的内容" class="headerlink" title="查看地址0x402400的内容"></a>查看地址0x402400的内容</h3><p>现在我们看看向寄存器%esi存入的是什么内容：<br>使用gdb运行bomb</p><pre class="line-numbers language-bash"><code class="language-bash">gdb bomb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="pic1.png" alt="运行gdb"></p><p>在函数phase_1 和 explode_bomb 处 设置断点</p><pre class="line-numbers language-bash"><code class="language-bash">b phase_1b explode_bomb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="pic2.png" alt="设置断点"></p><p>运行程序: </p><pre class="line-numbers language-bash"><code class="language-bash">r<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="pic3.png" alt="运行bomb"></p><p>下面随便输入一串字符”aaa”，然后运行到断点<br><img src="pic4.png" alt="执行到断点"></p><p>我们来看看内存0x402400的内容,因为这是一个字符串，我们使用x/s命令：</p><pre class="line-numbers language-bash"><code class="language-bash">x/s 0x402400<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="pic5.png" alt="0x402400内容"><br>我们看到字符串为： </p><blockquote><p>Border relations with Canada have never been better.</p></blockquote><p>这就是阶段1的答案。<br>下面我们验证一下：<br>使用指令q退出gdb调试，然后重新运行gdb。<br>以防万一，我们先在explode_bomb设置断点，然后运行bomb。<br>输入字符串 Border relations with Canada have never been better. 第一阶段完成~<br><img src="pic6.png" alt="第一阶段"></p><blockquote><p>为了后续调试不需要手动输入之前的解码，我们把answer保存在answer.txt文件下，之后运行只需要输入r &lt; answer.txt即可。</p></blockquote><h2 id="三、phase-2"><a href="#三、phase-2" class="headerlink" title="三、phase_2"></a>三、phase_2</h2><h3 id="分析代码"><a href="#分析代码" class="headerlink" title="分析代码"></a>分析代码</h3><h4 id="片段一：循环之前"><a href="#片段一：循环之前" class="headerlink" title="片段一：循环之前"></a>片段一：循环之前</h4><p>首先看前五个指令：</p><pre class="line-numbers language-assembly"><code class="language-assembly">  400efc:    55                       push   %rbp # 将寄存器%rbp压栈  400efd:    53                       push   %rbx # 将寄存器%rbx压栈  400efe:    48 83 ec 28              sub    $0x28,%rsp # 分配栈帧空间，大小为40字节  400f02:    48 89 e6                 mov    %rsp,%rsi  # 将栈指针%rsp的值  400f05:    e8 52 05 00 00           callq  40145c <read_six_numbers> # 调用函数，读取六个数字<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>阅读代码可以发现，这次要输入的为6个数。我们继续往下分析</p><pre class="line-numbers language-assembly"><code class="language-assembly">  400f0a:    83 3c 24 01              cmpl   $0x1,(%rsp) # 将Mem[%rsp]和1比较  400f0e:    74 20                    je     400f30 <phase_2+0x34> # 如果这个数等于1，跳转到400f30  400f10:    e8 25 05 00 00           callq  40143a <explode_bomb> # 引爆炸弹  400f15:    eb 19                    jmp    400f30 <phase_2+0x34> # 跳转到400f30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>第一条指令将Mem[%rsp]的值与1进行比较。Mem[%rsp]存储的是什么呢？我们看最开始的5条指令：</p><pre class="line-numbers language-assembly"><code class="language-assembly">  400efc:    55                       push   %rbp # 将寄存器%rbp压栈  400efd:    53                       push   %rbx # 将寄存器%rbx压栈  400efe:    48 83 ec 28              sub    $0x28,%rsp # 分配栈帧空间，大小为40字节  400f02:    48 89 e6                 mov    %rsp,%rsi  # 将栈指针%rsp的值  400f05:    e8 52 05 00 00           callq  40145c <read_six_numbers> # 调用函数，读取六个数字<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先传入函数<strong>phase_2</strong>的只有1个参数——字符串，它存放在寄存器%rdi中（这是字符串第一个元素的地址）。<br>然后又将%rsp的值存储到%rsi中，然后调用函数<strong>read_six_numbers</strong>。<br>因此字符串%rdi作为<strong>read_six_numbers</strong>的第一个参数，%rsp作为该函数的第二个参数。<br>这里我猜想执行完函数后，Mem[%rsp]存储了我们输入的第一个数，<br>后面的数依次存放在Mem[%rsp + 0x4], Mem[%rsp + 0x8], Mem[%rsp + 0xc], Mem[%rsp + 0x10], Mem[%rsp + 0x14]。<br>我们用gdb来验证猜想：<br>首先在answer.txt中添加输入：“2 3 4 5 6 7”，然后调试程序。<br><strong>注意：这次断点需要打在指定的指令上，如果只在<em>explode_bomb</em>函数打断点，仍然会执行callq指令，该指令会把调用函数后需要返回的地址（下一条执行指令的地址）压栈。这样使用x/d $rsp就不会得到想要的结果</strong></p><h5 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h5><pre class="line-numbers language-bash"><code class="language-bash">b explode_bombb *0x400f0ar <span class="token operator">&lt;</span> answer.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="pic7.png" alt="设置断点"></p><h5 id="查看栈帧Mem-rsp-中连续6个空间-4Bytes-6-的内容"><a href="#查看栈帧Mem-rsp-中连续6个空间-4Bytes-6-的内容" class="headerlink" title="查看栈帧Mem[%rsp]中连续6个空间(4Bytes * 6)的内容"></a>查看栈帧Mem[%rsp]中连续6个空间(4Bytes * 6)的内容</h5><pre class="line-numbers language-bash"><code class="language-bash">x/6dw <span class="token variable">$rsp</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="pic8.png" alt="查看栈帧"></p><p>内容分别为2 3 4 5 6，与我们的输入顺序一致，猜想正确。<br>而根据指令，我们可以发现：第一个数必须为1。<br>我们继续往下看。</p><p>执行完判断后，指令跳转到400f30。我们来看看400f30这个片段代码：</p><pre class="line-numbers language-assembly"><code class="language-assembly">  # .400f30  400f30:    48 8d 5c 24 04           lea    0x4(%rsp),%rbx # 将%rsp+4存储到%rbx中  400f35:    48 8d 6c 24 18           lea    0x18(%rsp),%rbp # 将%rsp+24存储到%rbp中  400f3a:    eb db                    jmp    400f17 <phase_2+0x1b> # 跳转到400f17<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>栈帧中这个数组每个元素的大小为4 bytes。将%rsp+4存储到%rbx中，相当于将下一个元素的地址保存到%rbx中。%rbp存储数组最后一个元素的下一个地址。<br>之后指令跳转到400f17，我们来看看这段指令。</p><h4 id="片段二：循环"><a href="#片段二：循环" class="headerlink" title="片段二：循环"></a>片段二：循环</h4><p>先来看看机器指令：</p><pre class="line-numbers language-assembly"><code class="language-assembly">  # .400f17  400f17:    8b 43 fc                 mov    -0x4(%rbx),%eax # 将Mem[%rbx-4]存储到%eax  400f1a:    01 c0                    add    %eax,%eax # %eax += %eax   400f1c:    39 03                    cmp    %eax,(%rbx) # 比较%eax和Mem[%rsp]  400f1e:    74 05                    je     400f25 <phase_2+0x29> # 如果相等，跳过引爆炸弹  400f20:    e8 15 05 00 00           callq  40143a <explode_bomb> # 引爆炸弹  400f25:    48 83 c3 04              add    $0x4,%rbx # %rbx += 4  400f29:    48 39 eb                 cmp    %rbp,%rbx # 比较%rbp 和 %rbx  400f2c:    75 e9                    jne    400f17 <phase_2+0x1b> # 如果不相等，跳转到400f17  400f2e:    eb 0c                    jmp    400f3c <phase_2+0x40> # 跳转到400f3c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将其转换为C语言代码</p><pre class="line-numbers language-C"><code class="language-C">void phase_2(int nums[6]) {    if(nums[0] != 1)        explode();    int *end = nums + 6;    int *p = nums + 1;    while (p != end) {        int temp = *(p - 1);        temp += temp;        if(*p != temp)            explode();        p++;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，数组中的每个元素都应该是前一个元素的两倍。由于第一个元素为1，所以这六个元素确定了：</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><blockquote><p>1 2 4 8 16 32</p></blockquote><p>第二阶段完成。<br><img src="pic9.png" alt="第二阶段"></p><h2 id="四、phase-3"><a href="#四、phase-3" class="headerlink" title="四、phase_3"></a>四、phase_3</h2><p>首先我们来分析机器指令</p><h3 id="分析指令"><a href="#分析指令" class="headerlink" title="分析指令"></a>分析指令</h3><h4 id="第一块：分配栈帧空间"><a href="#第一块：分配栈帧空间" class="headerlink" title="第一块：分配栈帧空间"></a>第一块：分配栈帧空间</h4><pre class="line-numbers language-assembly"><code class="language-assembly">  400f43:    48 83 ec 18              sub    $0x18,%rsp  400f47:    48 8d 4c 24 0c           lea    0xc(%rsp),%rcx  400f4c:    48 8d 54 24 08           lea    0x8(%rsp),%rdx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="第二块：读入数据"><a href="#第二块：读入数据" class="headerlink" title="第二块：读入数据"></a>第二块：读入数据</h4><pre><code>  400f51:    be cf 25 40 00           mov    $0x4025cf,%esi # 将0x4025cf存入寄存器%esi  400f56:    b8 00 00 00 00           mov    $0x0,%eax  # 将0存入寄存器%eax  400f5b:    e8 90 fc ff ff           callq  400bf0 &lt;__isoc99_sscanf@plt&gt; # 调用函数&lt;__isoc99_sscanf@plt&gt;   400f60:    83 f8 01                 cmp    $0x1,%eax # 将函数的返回值和1比较  400f63:    7f 05                    jg     400f6a &lt;phase_3+0x27&gt;  # 如果大于1, 跳过explode_bomb  400f65:    e8 d0 04 00 00           callq  40143a &lt;explode_bomb&gt;  # 引爆炸弹</code></pre><p>我们来看看Mem[0x4025cf]中存储的是什么内容：</p><pre class="line-numbers language-bash"><code class="language-bash">x/s 0x4025cf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们发现这是一个字符串”%d %d”。<br><img src="pic10.png" alt="0x4025cf"><br>根据C语言scanf的知识，可以断定，这次我们输入的内容应该是两个整数。<br>我们继续向下看：</p><h4 id="第三块：switch"><a href="#第三块：switch" class="headerlink" title="第三块：switch"></a>第三块：switch</h4><p>先看switch前的部分</p><pre class="line-numbers language-assembly"><code class="language-assembly">  400f6a:    83 7c 24 08 07           cmpl   $0x7,0x8(%rsp) # 将Mem[%rsp+0x8]与7比较  400f6f:    77 3c                    ja     400fad <phase_3+0x6a>  # 如果大于7（无符号型），跳到爆炸  400f71:    8b 44 24 08              mov    0x8(%rsp),%eax # 把Mem[%rsp+0x8]写入寄存器%eax  400f75:    ff 24 c5 70 24 40 00     jmpq   *0x402470(,%rax,8) # Jump Table<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们发现需要输入的第一个数要小于等于7，然后会根据我们输入的数进行switch跳转。<br>Mem[0x402470]存放了Jump Table，我们用 x/8xg 0x402470 来查看Jump Table的内容：</p><pre class="line-numbers language-bash"><code class="language-bash">x/8xg 0x402470<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="pic11.png" alt="Jump Table"><br>然后根据这个，我们可以得到如下的跳转关系：</p><blockquote><p>0 -&gt; 400f7c<br>1 -&gt; 400fb9<br>2 -&gt; 400f83<br>3 -&gt; 400f8a<br>4 -&gt; 400f91<br>5 -&gt; 400f98<br>6 -&gt; 400f9f<br>7 -&gt; 400fa6</p></blockquote><p>我们来看跳转后的指令：</p><pre class="line-numbers language-assembly"><code class="language-assembly">  # 0  400f7c:    b8 cf 00 00 00           mov    $0xcf,%eax  400f81:    eb 3b                    jmp    400fbe <phase_3+0x7b>  # 2  400f83:    b8 c3 02 00 00           mov    $0x2c3,%eax  400f88:    eb 34                    jmp    400fbe <phase_3+0x7b>  # 3  400f8a:    b8 00 01 00 00           mov    $0x100,%eax  400f8f:    eb 2d                    jmp    400fbe <phase_3+0x7b>  # 4  400f91:    b8 85 01 00 00           mov    $0x185,%eax  400f96:    eb 26                    jmp    400fbe <phase_3+0x7b>  # 5  400f98:    b8 ce 00 00 00           mov    $0xce,%eax  400f9d:    eb 1f                    jmp    400fbe <phase_3+0x7b>  # 6  400f9f:    b8 aa 02 00 00           mov    $0x2aa,%eax  400fa4:    eb 18                    jmp    400fbe <phase_3+0x7b>  # 7  400fa6:    b8 47 01 00 00           mov    $0x147,%eax  400fab:    eb 11                    jmp    400fbe <phase_3+0x7b>  # .400fad  400fad:    e8 88 04 00 00           callq  40143a <explode_bomb>  400fb2:    b8 00 00 00 00           mov    $0x0,%eax  # 1  400fb7:    eb 05                    jmp    400fbe <phase_3+0x7b>  400fb9:    b8 37 01 00 00           mov    $0x137,%eax  # .400fbe  400fbe:    3b 44 24 0c              cmp    0xc(%rsp),%eax  400fc2:    74 05                    je     400fc9 <phase_3+0x86>  400fc4:    e8 71 04 00 00           callq  40143a <explode_bomb>  400fc9:    48 83 c4 18              add    $0x18,%rsp  400fcd:    c3                       retq   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每条case分支都是将一个数写入寄存器%rax，然后把我们输入的第二个数和它比较是否相等。如果相等，这个阶段解决。</p><h3 id="所以本阶段的答案-任选一个"><a href="#所以本阶段的答案-任选一个" class="headerlink" title="所以本阶段的答案:(任选一个)"></a>所以本阶段的答案:(任选一个)</h3><blockquote><p>0 207<br>1 311<br>2 707<br>3 256<br>4 389<br>5 206<br>6 682<br>7 327</p></blockquote><h2 id="五、phase-4"><a href="#五、phase-4" class="headerlink" title="五、phase_4"></a>五、phase_4</h2><p>我们来看这一阶段指令</p><h3 id="分析指令-1"><a href="#分析指令-1" class="headerlink" title="分析指令"></a>分析指令</h3><h4 id="片段一：调用函数前"><a href="#片段一：调用函数前" class="headerlink" title="片段一：调用函数前"></a>片段一：调用函数前</h4><pre class="line-numbers language-assembly"><code class="language-assembly">  40100c:    48 83 ec 18              sub    $0x18,%rsp  401010:    48 8d 4c 24 0c           lea    0xc(%rsp),%rcx  401015:    48 8d 54 24 08           lea    0x8(%rsp),%rdx  40101a:    be cf 25 40 00           mov    $0x4025cf,%esi  40101f:    b8 00 00 00 00           mov    $0x0,%eax  401024:    e8 c7 fb ff ff           callq  400bf0 <__isoc99_sscanf@plt>  401029:    83 f8 02                 cmp    $0x2,%eax  40102c:    75 07                    jne    401035 <phase_4+0x29>  # 如果不相等，引爆炸弹<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和前一阶段一样，本阶段也是输入两个数。调用函数 <strong>isoc99_sscanf@plt</strong> 将返回我们输入数的个数。如果不为2，引爆炸弹。<br>继续往下看：</p><pre class="line-numbers language-assembly"><code class="language-assembly">  40102e:    83 7c 24 08 0e           cmpl   $0xe,0x8(%rsp) # 比较Mem[%rsp + 8]和16  401033:    76 05                    jbe    40103a <phase_4+0x2e> # 如果小于等于16，跳过炸弹  401035:    e8 00 04 00 00           callq  40143a <explode_bomb>  40103a:    ba 0e 00 00 00           mov    $0xe,%edx  # %edx = 16  40103f:    be 00 00 00 00           mov    $0x0,%esi  # %esi = 0  401044:    8b 7c 24 08              mov    0x8(%rsp),%edi # %edi = Mem[%rsp + 8]  401048:    e8 81 ff ff ff           callq  400fce <func4> # 调用函数  40104d:    85 c0                    test   %eax,%eax # 判断返回值  40104f:    75 07                    jne    401058 <phase_4+0x4c> # 如果返回值不为0，引爆<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和上一阶段一样，Mem[%rsp + 8]存的时我们输入的第一个数。输入的数小于等于16时，它会调用函数 <strong>func4</strong> 。其中函数的调用参数如下:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">func4</span><span class="token punctuation">(</span>first_num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>并且函数的返回值必须是0。<br>那我们来看看<strong>func4</strong>函数</p><h4 id="片段二：函数-func4"><a href="#片段二：函数-func4" class="headerlink" title="片段二：函数 func4"></a>片段二：函数 func4</h4><p>机器指令如下：</p><pre class="line-numbers language-assembly"><code class="language-assembly">0000000000400fce <func4>:  400fce:    48 83 ec 08              sub    $0x8,%rsp # allocate stack space  400fd2:    89 d0                    mov    %edx,%eax # move %edx -> %eax  400fd4:    29 f0                    sub    %esi,%eax # %eax -= %esi  400fd6:    89 c1                    mov    %eax,%ecx #   400fd8:    c1 e9 1f                 shr    $0x1f,%ecx  400fdb:    01 c8                    add    %ecx,%eax  400fdd:    d1 f8                    sar    %eax  400fdf:    8d 0c 30                 lea    (%rax,%rsi,1),%ecx  400fe2:    39 f9                    cmp    %edi,%ecx  400fe4:    7e 0c                    jle    400ff2 <func4+0x24>  400fe6:    8d 51 ff                 lea    -0x1(%rcx),%edx  400fe9:    e8 e0 ff ff ff           callq  400fce <func4>  400fee:    01 c0                    add    %eax,%eax  400ff0:    eb 15                    jmp    401007 <func4+0x39>  # .Block1  400ff2:    b8 00 00 00 00           mov    $0x0,%eax  400ff7:    39 f9                    cmp    %edi,%ecx  400ff9:    7d 0c                    jge    401007 <func4+0x39>  400ffb:    8d 71 01                 lea    0x1(%rcx),%esi  400ffe:    e8 cb ff ff ff           callq  400fce <func4>  401003:    8d 44 00 01              lea    0x1(%rax,%rax,1),%eax  401007:    48 83 c4 08              add    $0x8,%rsp  40100b:    c3                   func4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>转换成C语言:</p><pre class="line-numbers language-C"><code class="language-C">int fun4(int x, int y, int z) {    int val = z - y;    int temp = (val >> 31); //if negative    val = (val + temp) >> 1;    temp = val + y;    if(temp - x <= 0) {        val = 0;        if(temp - x >= 0) { // x == temp            return 0;        }    }    z -= 1;    val += fun4(x, y, z);    return val;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据C语言逻辑，要想</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">func4</span><span class="token punctuation">(</span>first_num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第一个参数必须为7。因此我们输入的第一个数为7.</p><h4 id="片段三：第二个数"><a href="#片段三：第二个数" class="headerlink" title="片段三：第二个数"></a>片段三：第二个数</h4><pre><code>  401051:    83 7c 24 0c 00           cmpl   $0x0,0xc(%rsp)  401056:    74 05                    je     40105d &lt;phase_4+0x51&gt;  401058:    e8 dd 03 00 00           callq  40143a &lt;explode_bomb&gt;  40105d:    48 83 c4 18              add    $0x18,%rsp  401061:    c3                       retq   </code></pre><p>Mem[%rsp+12]存储的是我们输入的第二个数。只有这个数为0时，才能逃过炸弹。因此答案很明显了。</p><h3 id="本阶段答案"><a href="#本阶段答案" class="headerlink" title="本阶段答案"></a>本阶段答案</h3><blockquote><p>7 0</p></blockquote><p><img src="pic12.png" alt="第四阶段"></p><h2 id="六、phase-5"><a href="#六、phase-5" class="headerlink" title="六、phase_5"></a>六、phase_5</h2><h3 id="分析指令-2"><a href="#分析指令-2" class="headerlink" title="分析指令"></a>分析指令</h3><h4 id="片段一：读取输入"><a href="#片段一：读取输入" class="headerlink" title="片段一：读取输入"></a>片段一：读取输入</h4><pre class="line-numbers language-assembly"><code class="language-assembly">  401062:    53                       push   %rbx  401063:    48 83 ec 20              sub    $0x20,%rsp  401067:    48 89 fb                 mov    %rdi,%rbx # 将输入的字符串(首地址)保存在%rbx  40106a:    64 48 8b 04 25 28 00     mov    %fs:0x28,%rax  401071:    00 00   401073:    48 89 44 24 18           mov    %rax,0x18(%rsp)  401078:    31 c0                    xor    %eax,%eax  40107a:    e8 9c 02 00 00           callq  40131b <string_length>  40107f:    83 f8 06                 cmp    $0x6,%eax  401082:    74 4e                    je     4010d2 <phase_5+0x70>  401084:    e8 b1 03 00 00           callq  40143a <explode_bomb><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到这部分先计算输入字符串的长度，如果长度不为6，就引爆炸弹。<br>那么是哪六个字符呢？我们继续看。</p><h4 id="片段二：循环-1"><a href="#片段二：循环-1" class="headerlink" title="片段二：循环"></a>片段二：循环</h4><p>刚才跳转到4010d2，我们来看这段指令：</p><pre class="line-numbers language-assembly"><code class="language-assembly">  4010d2:    b8 00 00 00 00           mov    $0x0,%eax  # %eax = 0  4010d7:    eb b2                    jmp    40108b <phase_5+0x29><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>继续跳转40108b：</p><pre class="line-numbers language-assembly"><code class="language-assembly">  40108b:    0f b6 0c 03              movzbl (%rbx,%rax,1),%ecx # %ecx = Mem[%rbx + %rax]  40108f:    88 0c 24                 mov    %cl,(%rsp) # Mem[%rsp] = %cl(寄存器%ecx低位的1字节)  401092:    48 8b 14 24              mov    (%rsp),%rdx # %rdx = %cl  401096:    83 e2 0f                 and    $0xf,%edx  # %rdx &= 0xf 只保留低位四字节  401099:    0f b6 92 b0 24 40 00     movzbl 0x4024b0(%rdx),%edx  # %edx = Mem[0x4024b0 + %rdx]  4010a0:    88 54 04 10              mov    %dl,0x10(%rsp,%rax,1)  # Mem[%rsp + 16 + %rax] = %dl  4010a4:    48 83 c0 01              add    $0x1,%rax  # %rax += 1  4010a8:    48 83 f8 06              cmp    $0x6,%rax  # 比较%rax 和 6  4010ac:    75 dd                    jne    40108b <phase_5+0x29>  # 如果不等于6，继续循环<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出来，这是一个循环。%eax在循环中会自增，而且我们根据%eax的值来获取字符串中的字符，所以%eax是保存当前字符的下标。<br>我们用x/s 0x4024b0 来看看这里存的是什么：<br><img src="pic13.png" alt="0x4024b0"><br>这段字符串为：”maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?”<br>对%edx使用了位屏蔽，只保留第四位的值，所以%edx的范围是[0,15]，<br>所以上面的字符串有效的部分为“aduiersnfotvbyl”。这个字符串相当与字典，它会根据%edx的大小从其中选取对应下标的字符存储在Mem[%rsp + 16 + %rax]中。<br>我们把循环改成C语言：</p><pre class="line-numbers language-c"><code class="language-c">    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> dictionary<span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"maduiersnfotvbyl"</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>length <span class="token operator">!=</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">explode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> c<span class="token punctuation">;</span>    <span class="token keyword">char</span> res_str<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">!=</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        c <span class="token operator">=</span> s<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>        res_str<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> dictionary<span class="token punctuation">[</span>c <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>继续往下看：</p><pre class="line-numbers language-assembly"><code class="language-assembly">  4010ae:    c6 44 24 16 00           movb   $0x0,0x16(%rsp)  4010b3:    be 5e 24 40 00           mov    $0x40245e,%esi  4010b8:    48 8d 7c 24 10           lea    0x10(%rsp),%rdi  4010bd:    e8 76 02 00 00           callq  401338 <strings_not_equal>  4010c2:    85 c0                    test   %eax,%eax  4010c4:    74 13                    je     4010d9 <phase_5+0x77>  4010c6:    e8 6f 03 00 00           callq  40143a <explode_bomb>  4010cb:    0f 1f 44 00 00           nopl   0x0(%rax,%rax,1)  4010d0:    eb 07                    jmp    4010d9 <phase_5+0x77><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一条指令给新生成字符数组的末尾加上了’\0’，使它成为了字符串。<br>然后比较0x40245e和当前字符串。<br>通过指令 x/s 0x40245e 我们看到字符串为”flyers”。</p><blockquote><p>要构造这个字符串，我们需要的字典下标为:<br>9 15 14 5 6 7<br>对应的二进制为:<br>1001 1111 1110 0101 0110 0111</p></blockquote><p>我们输入的字符串ASCII码二进制形式的低位需要是这些数。<br>因此我们可以得到答案：</p><h3 id="其中一个答案"><a href="#其中一个答案" class="headerlink" title="其中一个答案"></a>其中一个答案</h3><blockquote><p>IONEFG</p></blockquote><p><img src="pic14.png" alt="第五阶段"></p><h2 id="七、phase-6"><a href="#七、phase-6" class="headerlink" title="七、phase_6"></a>七、phase_6</h2><h3 id="分析指令-3"><a href="#分析指令-3" class="headerlink" title="分析指令"></a>分析指令</h3><h4 id="片段一：读取6个数"><a href="#片段一：读取6个数" class="headerlink" title="片段一：读取6个数"></a>片段一：读取6个数</h4><p>我们来看指令：</p><pre class="line-numbers language-assembly"><code class="language-assembly">  4010f4:    41 56                    push   %r14  4010f6:    41 55                    push   %r13  4010f8:    41 54                    push   %r12  4010fa:    55                       push   %rbp  4010fb:    53                       push   %rbx  4010fc:    48 83 ec 50              sub    $0x50,%rsp  401100:    49 89 e5                 mov    %rsp,%r13  401103:    48 89 e6                 mov    %rsp,%rsi  401106:    e8 51 03 00 00           callq  40145c <read_six_numbers>  # 调用函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从这我们可以看出，我们输入的应该是6个数。将%rsp的内容写入%rsi，作为函数的调用参数。所以我们输入的6个数将会存放在栈帧中。<br>为了验证这个，我们使用GDB调试。输入6个数：11 22 33 44 55 66<br>使用命令： </p><pre class="line-numbers language-bash"><code class="language-bash">x/6dw <span class="token variable">$rsp</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="pic15.png" alt="栈帧"><br>可以看到，Mem[%rsp]及之后连续的地址内存放了我们输入的六个数，猜想正确。</p><h4 id="片段二：循环判断"><a href="#片段二：循环判断" class="headerlink" title="片段二：循环判断"></a>片段二：循环判断</h4><p>我们来看指令：</p><pre class="line-numbers language-assembly"><code class="language-assembly">  40110b:    49 89 e6                 mov    %rsp,%r14  # 将数组的首地址存储在%r14  40110e:    41 bc 00 00 00 00        mov    $0x0,%r12d # %r12d = 0  # .401114  401114:    4c 89 ed                 mov    %r13,%rbp  # %rbp = %r13 = %rsp  401117:    41 8b 45 00              mov    0x0(%r13),%eax # %eax = Mem[%r13 + 0]  40111b:    83 e8 01                 sub    $0x1,%eax  # %eax -= 1;  40111e:    83 f8 05                 cmp    $0x5,%eax  # 比较5和%eax  401121:    76 05                    jbe    401128 <phase_6+0x34>  # 如果小于等于5，跳过引爆炸弹  401123:    e8 12 03 00 00           callq  40143a <explode_bomb>  401128:    41 83 c4 01              add    $0x1,%r12d # %r12d += 1  40112c:    41 83 fc 06              cmp    $0x6,%r12d # %12d :6  401130:    74 21                    je     401153 <phase_6+0x5f>  # 如果等于6，跳转  401132:    44 89 e3                 mov    %r12d,%ebx # %ebx = %r12d  401135:    48 63 c3                 movslq %ebx,%rax  # %eax = %ebx  401138:    8b 04 84                 mov    (%rsp,%rax,4),%eax # %eax = Mem[%rsp + 4 * %rax]  40113b:    39 45 00                 cmp    %eax,0x0(%rbp) # %eax:Mem[%rbp]  40113e:    75 05                    jne    401145 <phase_6+0x51> # 如果不相等，跳过炸弹  401140:    e8 f5 02 00 00           callq  40143a <explode_bomb>    401145:    83 c3 01                 add    $0x1,%ebx  # %ebx += 1  401148:    83 fb 05                 cmp    $0x5,%ebx  # %rbx : 5  40114b:    7e e8                    jle    401135 <phase_6+0x41>  # 如果小于等于5  40114d:    49 83 c5 04              add    $0x4,%r13  # %r13 += 4  401151:    eb c1                    jmp    401114 <phase_6+0x20>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将其转换成C语言(伪代码，有些缺失)：</p><pre class="line-numbers language-assembly"><code class="language-assembly">int nums[6];    int rsi, edx;    read_six_numbers(nums);    //All the number ranges in [1, 6] (Incomplete code)    if(nums[0] - 1 >= 5) {        explode();    }    int index = 0; //%r12    while(index != 6) {        index++;        if(index == 6)             break;        int temp = index;   //%ebx        Loop1:            int val = nums[index];     //eax            if(val == 0)            explode();            temp++;            if(temp <= 5)                goto Loop1;        //    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现，所有的数都要在[1,6]范围内，并且互不相同。</p><h4 id="片段三：循环操作"><a href="#片段三：循环操作" class="headerlink" title="片段三：循环操作"></a>片段三：循环操作</h4><pre class="line-numbers language-assembly"><code class="language-assembly">  # .501153  401153:    48 8d 74 24 18           lea    0x18(%rsp),%rsi # %rsi = nums[6] addr, end of the array  401158:    4c 89 f0                 mov    %r14,%rax # mov the 1st num addr in rax  40115b:    b9 07 00 00 00           mov    $0x7,%ecx # ecx = 7  # .401160  401160:    89 ca                    mov    %ecx,%edx # edx = ecx  401162:    2b 10                    sub    (%rax),%edx # edx -= (%rax)  401164:    89 10                    mov    %edx,(%rax) # (%rax) = edx  401166:    48 83 c0 04              add    $0x4,%rax # %rax += 4 -> next num  40116a:    48 39 f0                 cmp    %rsi,%rax   40116d:    75 f1                    jne    401160 <phase_6+0x6c>  40116f:    be 00 00 00 00           mov    $0x0,%esi  401174:    eb 21                    jmp    401197 <phase_6+0xa3><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>转换成C语言：</p><pre class="line-numbers language-C"><code class="language-C">for(int i = 0; i < 6; ++i) {        nums[i] = 7 - nums[i];    }    rsi = 0;    goto L401197;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，之一阶段把每个数变成 7-原数</p><h4 id="片段四：发现链表"><a href="#片段四：发现链表" class="headerlink" title="片段四：发现链表"></a>片段四：发现链表</h4><p>接着，指令跳转到401197</p><pre><code>  # .401197  401197:    8b 0c 34                 mov    (%rsp,%rsi,1),%ecx # %ecx = num[?]  40119a:    83 f9 01                 cmp    $0x1,%ecx   40119d:    7e e4                    jle    401183 &lt;phase_6+0x8f&gt; # $ecx &lt;= 1, jump  40119f:    b8 01 00 00 00           mov    $0x1,%eax  4011a4:    ba d0 32 60 00           mov    $0x6032d0,%edx  4011a9:    eb cb                    jmp    401176 &lt;phase_6+0x82&gt;</code></pre><p>我们来看看0x6032d0存储的内容：<br>我们使用指令：(一开始可以先用x/d 0x6032d0，发现它是node，然后我们多取几位地址)</p><pre class="line-numbers language-bash"><code class="language-bash">x/12xg 0x6032d0得到如下结果：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">0x6032d0 <span class="token operator">&lt;</span>node1<span class="token operator">></span>:    0x000000010000014c    0x00000000006032e00x6032e0 <span class="token operator">&lt;</span>node2<span class="token operator">></span>:    0x00000002000000a8    0x00000000006032f00x6032f0 <span class="token operator">&lt;</span>node3<span class="token operator">></span>:    0x000000030000039c    0x00000000006033000x603300 <span class="token operator">&lt;</span>node4<span class="token operator">></span>:    0x00000004000002b3    0x00000000006033100x603310 <span class="token operator">&lt;</span>node5<span class="token operator">></span>:    0x00000005000001dd    0x00000000006033200x603320 <span class="token operator">&lt;</span>node6<span class="token operator">></span>:    0x00000006000001bb    0x0000000000000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们发现这是6个结点构成的空间，他们组成了一个链表:</p><pre class="line-numbers language-C"><code class="language-C">struct node {  long x;  node* next;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>链表的前半部分存储的是数据，后半部分存储的是下一个结点的地址。<br>继续往下看：</p><pre class="line-numbers language-assembly"><code class="language-assembly">  # .401176  401176:    48 8b 52 08              mov    0x8(%rdx),%rdx  40117a:    83 c0 01                 add    $0x1,%eax  40117d:    39 c8                    cmp    %ecx,%eax  40117f:    75 f5                    jne    401176 <phase_6+0x82>  401181:    eb 05                    jmp    401188 <phase_6+0x94>  # .401183  401183:    ba d0 32 60 00           mov    $0x6032d0,%edx   # .401188  401188:    48 89 54 74 20           mov    %rdx,0x20(%rsp,%rsi,2)  40118d:    48 83 c6 04              add    $0x4,%rsi  401191:    48 83 fe 18              cmp    $0x18,%rsi  401195:    74 14                    je     4011ab <phase_6+0xb7><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将其转换成C语言(goto形式):</p><pre class="line-numbers language-c"><code class="language-c">    L401176<span class="token punctuation">:</span>        rdx <span class="token operator">=</span> Mem<span class="token punctuation">[</span>rdx <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        eax <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>eax <span class="token operator">!=</span> ecx<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">goto</span> L401176<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">goto</span> L401188<span class="token punctuation">;</span>    L401183<span class="token punctuation">:</span>        edx <span class="token operator">=</span> <span class="token number">0x6032d0</span><span class="token punctuation">;</span>    L401188<span class="token punctuation">:</span>        Mem<span class="token punctuation">[</span>rsp <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> rsi <span class="token operator">+</span> <span class="token number">0x20</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdx<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//Save Node addr in the end of array</span>        rsi <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>rsi <span class="token operator">==</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">goto</span> L4011ab<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    L401197<span class="token punctuation">:</span>        ecx <span class="token operator">=</span> nums<span class="token punctuation">[</span>rsi <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ecx <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 7-nums[i] &lt;= 1</span>            <span class="token keyword">goto</span> L401183<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        eax <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        edx <span class="token operator">=</span> <span class="token number">0x6032d0</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> L401176<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码的意思如下：<br>将链表的每个结点从1~6编号，变化后nums[]数组中的值与结点形成映射关系。<br>将nums[]数组对应的结点地址依次存放到栈帧空间。</p><h4 id="片段五：构成新链表"><a href="#片段五：构成新链表" class="headerlink" title="片段五：构成新链表"></a>片段五：构成新链表</h4><pre class="line-numbers language-assembly"><code class="language-assembly">  # .4011ab  4011ab:    48 8b 5c 24 20           mov    0x20(%rsp),%rbx  4011b0:    48 8d 44 24 28           lea    0x28(%rsp),%rax  4011b5:    48 8d 74 24 50           lea    0x50(%rsp),%rsi  4011ba:    48 89 d9                 mov    %rbx,%rcx  # .4011bd  4011bd:    48 8b 10                 mov    (%rax),%rdx  4011c0:    48 89 51 08              mov    %rdx,0x8(%rcx)  4011c4:    48 83 c0 08              add    $0x8,%rax  4011c8:    48 39 f0                 cmp    %rsi,%rax  4011cb:    74 05                    je     4011d2 <phase_6+0xde>  4011cd:    48 89 d1                 mov    %rdx,%rcx  4011d0:    eb eb                    jmp    4011bd <phase_6+0xc9>  # .4011d2  4011e3:    8b 00                    mov    (%rax),%eax # long->int  4011e5:    39 03                    cmp    %eax,(%rbx)  4011d2:    48 c7 42 08 00 00 00     movq   $0x0,0x8(%rdx)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将其转换成C语言：</p><pre class="line-numbers language-c"><code class="language-c">    L4011ab<span class="token punctuation">:</span>        rbx <span class="token operator">=</span> Mem<span class="token punctuation">[</span>rsp <span class="token operator">+</span> <span class="token number">0x20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// the first node</span>        rax <span class="token operator">=</span> rsp <span class="token operator">+</span> <span class="token number">0x28</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// the second node addr</span>        rsi <span class="token operator">=</span> rsp <span class="token operator">+</span> <span class="token number">0x50</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// end of the array</span>        rcx <span class="token operator">=</span> rbx<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//Change this node next pointer, make them a new linklist</span>    L4011bd<span class="token punctuation">:</span>        rdx <span class="token operator">=</span> Mem<span class="token punctuation">[</span>rax<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// the second node</span>        Mem<span class="token punctuation">[</span>rcx <span class="token operator">+</span> <span class="token number">0x8</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdx<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//the node next pointer</span>        rax <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//the next node in array</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>rax <span class="token operator">==</span> rsi<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">goto</span> L4011d2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">goto</span> L4011bd<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//set the endNode->next to NULL</span>    L4011d2<span class="token punctuation">:</span>        Mem<span class="token punctuation">[</span>rdx <span class="token operator">+</span> <span class="token number">0x8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码将结点按新的顺序重新连接成新的链表。</p><h4 id="片段六：比较链表中结点的数据域"><a href="#片段六：比较链表中结点的数据域" class="headerlink" title="片段六：比较链表中结点的数据域"></a>片段六：比较链表中结点的数据域</h4><pre class="line-numbers language-assembly"><code class="language-assembly">  4011da:    bd 05 00 00 00           mov    $0x5,%ebp  # .4011df  4011df:    48 8b 43 08              mov    0x8(%rbx),%rax  4011e3:    8b 00                    mov    (%rax),%eax # long->int  4011e5:    39 03                    cmp    %eax,(%rbx)  4011e7:    7d 05                    jge    4011ee <phase_6+0xfa>  4011e9:    e8 4c 02 00 00           callq  40143a <explode_bomb>  4011ee:    48 8b 5b 08              mov    0x8(%rbx),%rbx  4011f2:    83 ed 01                 sub    $0x1,%ebp  4011f5:    75 e8                    jne    4011df <phase_6+0xeb> # ebp != 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>转换成C语言</p><pre class="line-numbers language-c"><code class="language-c">    <span class="token comment" spellcheck="true">//The new linklist should in descending order</span>    L4011df<span class="token punctuation">:</span>        rax <span class="token operator">=</span> Mem<span class="token punctuation">[</span>rbx <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// now node->data</span>        eax <span class="token operator">=</span> Mem<span class="token punctuation">[</span>rax<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//next node->data</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>rbx <span class="token operator">&lt;</span> eax<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//unsigned</span>            <span class="token function">explode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        rbx <span class="token operator">=</span> Mem<span class="token punctuation">[</span>rbx <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        ebp <span class="token operator">-</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ebp <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">goto</span> L4011df<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    OK<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从这段代码可以看出：它比较链表中的每个值，链表为降序才能通过，否则引爆。<br>注意这里</p><pre class="line-numbers language-assembly"><code class="language-assembly">  4011e3:    8b 00                    mov    (%rax),%eax # long->int  4011e5:    39 03                    cmp    %eax,(%rbx)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>它将数据转换成32位整形比较！<br>这样这个阶段就可以解决了！</p><h3 id="解决答案"><a href="#解决答案" class="headerlink" title="解决答案"></a>解决答案</h3><p>1.首先我们输入的这六个数在[1,6]范围内。<br>2.这六个数在程序中转换成了 7 - nums[i]。<br>3.变换后的六个数，所对应的结点的值应该按递减的顺序。<br>各个结点的值：（已转换成int）</p><pre class="line-numbers language-bash"><code class="language-bash">0x6032d0 <span class="token operator">&lt;</span>node1<span class="token operator">></span>:    0x0000014c    0x00000000006032e00x6032e0 <span class="token operator">&lt;</span>node2<span class="token operator">></span>:    0x000000a8    0x00000000006032f00x6032f0 <span class="token operator">&lt;</span>node3<span class="token operator">></span>:    0x0000039c    0x00000000006033000x603300 <span class="token operator">&lt;</span>node4<span class="token operator">></span>:    0x000002b3    0x00000000006033100x603310 <span class="token operator">&lt;</span>node5<span class="token operator">></span>:    0x000001dd    0x00000000006033200x603320 <span class="token operator">&lt;</span>node6<span class="token operator">></span>:    0x000001bb    0x0000000000000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>将结点从大到小排序：3 4 5 6 1 2<br>那么7-nums[i]依次为：3 4 5 6 1 2<br>则nums[i]依次为：4 3 2 1 6 5</p></blockquote><blockquote><p>所以最终答案为：4 3 2 1 6 5</p></blockquote><p><img src="pic16.png" alt="解决"></p><h2 id="八、彩蛋题"><a href="#八、彩蛋题" class="headerlink" title="八、彩蛋题"></a>八、彩蛋题</h2><h3 id="进入彩蛋"><a href="#进入彩蛋" class="headerlink" title="进入彩蛋"></a>进入彩蛋</h3><p>汇编代码中 <em>phase_6</em> 后的 <em>fun7</em> 似乎没有用到，再看看汇编代码，它被 <em>secret_phase</em> 这个函数调用。<br>我们来看看哪里调用了 <em>secret_phase</em> 。<br>在 <em>phase_defused</em> 这部分中发现了调用。</p><pre class="line-numbers language-assembly"><code class="language-assembly">00000000004015c4 <phase_defused>:  4015c4:    48 83 ec 78              sub    $0x78,%rsp  4015c8:    64 48 8b 04 25 28 00     mov    %fs:0x28,%rax  4015cf:    00 00   4015d1:    48 89 44 24 68           mov    %rax,0x68(%rsp)  4015d6:    31 c0                    xor    %eax,%eax  4015d8:    83 3d 81 21 20 00 06     cmpl   $0x6,0x202181(%rip)        # 603760 <num_input_strings>  4015df:    75 5e                    jne    40163f <phase_defused+0x7b><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只有在0x202181(%rip)等于6的时候，才不会跳转。也就是说，只有当读取了6个字符串时，才会触发这个阶段。<br>继续往下看：</p><pre class="line-numbers language-assembly"><code class="language-assembly">  4015e1:    4c 8d 44 24 10           lea    0x10(%rsp),%r8  4015e6:    48 8d 4c 24 0c           lea    0xc(%rsp),%rcx  4015eb:    48 8d 54 24 08           lea    0x8(%rsp),%rdx  4015f0:    be 19 26 40 00           mov    $0x402619,%esi  4015f5:    bf 70 38 60 00           mov    $0x603870,%edi  4015fa:    e8 f1 f5 ff ff           callq  400bf0 <__isoc99_sscanf@plt><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们在phase_6设置断点，查看内存地址0x402619，为：</p><blockquote><p>“%d %d %s”</p></blockquote><p>说明要读取的是两个数和一个字符串<br>我们继续查看0x603870，得到”7 0”。这正好是我们在第四阶段输入的答案。而且这一阶段的输入正好对应了前面的”%d %d”。<br>因此可以猜测，彩蛋题的答案应追加在第四阶段的答案上。</p><pre class="line-numbers language-assembly"><code class="language-assembly">  4015ff:    83 f8 03                 cmp    $0x3,%eax  401602:    75 31                    jne    401635 <phase_defused+0x71>  401604:    be 22 26 40 00           mov    $0x402622,%esi  401609:    48 8d 7c 24 10           lea    0x10(%rsp),%rdi  40160e:    e8 25 fd ff ff           callq  401338 <strings_not_equal>  401613:    85 c0                    test   %eax,%eax  401615:    75 1e                    jne    401635 <phase_defused+0x71>  401617:    bf f8 24 40 00           mov    $0x4024f8,%edi  40161c:    e8 ef f4 ff ff           callq  400b10 <puts@plt>  401621:    bf 20 25 40 00           mov    $0x402520,%edi  401626:    e8 e5 f4 ff ff           callq  400b10 <puts@plt>  40162b:    b8 00 00 00 00           mov    $0x0,%eax  401630:    e8 0d fc ff ff           callq  401242 <secret_phase><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先判断我们输入的是不是对应3个内容。然后将0x402622移入%esi，并与我们输入的字符串进行比较。<br>通过命令 </p><pre class="line-numbers language-bash"><code class="language-bash">x/s 0x402622<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们可以看到内容为：</p><blockquote><p>“DrEvil”</p></blockquote><p>所以我们应该在7 0后面追加 DrEvil。<br><img src="pic17.png" alt="进入彩蛋"></p><h3 id="分析secret-phase"><a href="#分析secret-phase" class="headerlink" title="分析secret_phase"></a>分析secret_phase</h3><pre class="line-numbers language-assembly"><code class="language-assembly">0000000000401242 <secret_phase>:  401242:    53                       push   %rbx  401243:    e8 56 02 00 00           callq  40149e <read_line>  401248:    ba 0a 00 00 00           mov    $0xa,%edx  40124d:    be 00 00 00 00           mov    $0x0,%esi  401252:    48 89 c7                 mov    %rax,%rdi  401255:    e8 76 f9 ff ff           callq  400bd0 <strtol@plt>  40125a:    48 89 c3                 mov    %rax,%rbx  40125d:    8d 40 ff                 lea    -0x1(%rax),%eax  401260:    3d e8 03 00 00           cmp    $0x3e8,%eax  401265:    76 05                    jbe    40126c <secret_phase+0x2a>  401267:    e8 ce 01 00 00           callq  40143a <explode_bomb>  40126c:    89 de                    mov    %ebx,%esi  40126e:    bf f0 30 60 00           mov    $0x6030f0,%edi  401273:    e8 8c ff ff ff           callq  401204 <fun7>  401278:    83 f8 02                 cmp    $0x2,%eax  40127b:    74 05                    je     401282 <secret_phase+0x40>  40127d:    e8 b8 01 00 00           callq  40143a <explode_bomb>  401282:    bf 38 24 40 00           mov    $0x402438,%edi  401287:    e8 84 f8 ff ff           callq  400b10 <puts@plt>  40128c:    e8 33 03 00 00           callq  4015c4 <phase_defused><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先调用 <em>read_line</em> 读取一行输入，然后用所得的字符串调用 <em>strtol@plt</em> ，得到字符串对应的长整型。将长整型结果复制到%rbx中，令%eax = %rax-1。如果%eax &lt;= 0x3e8（1000）,跳过炸弹。所以字符串转换后的数应该小于1001.</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">strtol</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>跳过炸弹后，调用函数fun7(0x6030f0, %esi),%esi存储的是字符串对应的整形。<br><em>fun7</em> 返回值需要为2，否则引爆炸弹<br>那我们来看fun7</p><h3 id="分析fun7"><a href="#分析fun7" class="headerlink" title="分析fun7"></a>分析fun7</h3><p>我们先来看看之前出现的0x6030f0内存空间<br>x/x 0x6030f0<br><img src="pic18.png" alt="0x6030f0-1"><br>可以发现里边有一个整数，但这个是一个结构体，显示的内容还不完整，我们继续查看。</p><pre class="line-numbers language-bash"><code class="language-bash">x/100x 0x6030f0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="pic19.png" alt="0x6030f0-2"><br>我们发现这个结构体的第一块区域存了数据，后面两块存储的是地址，最后一块都为0。这和我们学过的二叉树很像！那猜想第一段地址为左孩子，第二段地址为右孩子，那么我们可以把这棵树构建出来。<br><img src="pic21.png" alt="二叉树"></p><pre class="line-numbers language-assembly"><code class="language-assembly">0000000000401204 <fun7>:  401204:    48 83 ec 08              sub    $0x8,%rsp  401208:    48 85 ff                 test   %rdi,%rdi  40120b:    74 2b                    je     401238 <fun7+0x34>  40120d:    8b 17                    mov    (%rdi),%edx  40120f:    39 f2                    cmp    %esi,%edx  401211:    7e 0d                    jle    401220 <fun7+0x1c>  401213:    48 8b 7f 08              mov    0x8(%rdi),%rdi  401217:    e8 e8 ff ff ff           callq  401204 <fun7>  40121c:    01 c0                    add    %eax,%eax  40121e:    eb 1d                    jmp    40123d <fun7+0x39>  401220:    b8 00 00 00 00           mov    $0x0,%eax  401225:    39 f2                    cmp    %esi,%edx  401227:    74 14                    je     40123d <fun7+0x39>  401229:    48 8b 7f 10              mov    0x10(%rdi),%rdi  40122d:    e8 d2 ff ff ff           callq  401204 <fun7>  401232:    8d 44 00 01              lea    0x1(%rax,%rax,1),%eax  401236:    eb 05                    jmp    40123d <fun7+0x39>  401238:    b8 ff ff ff ff           mov    $0xffffffff,%eax  40123d:    48 83 c4 08              add    $0x8,%rsp  401241:    c3                       retq   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>改写成C语言:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fun7</span><span class="token punctuation">(</span>TNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//edx</span>    <span class="token keyword">int</span> ret_val<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0xffffffff</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    val <span class="token operator">=</span> root<span class="token operator">-></span>data<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>val <span class="token operator">&lt;=</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">goto</span> L401220<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ret_val <span class="token operator">=</span> <span class="token function">fun7</span><span class="token punctuation">(</span>TNode<span class="token operator">-></span>left<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> ret_val<span class="token punctuation">;</span>    L401220<span class="token punctuation">:</span>        ret_val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ret_val <span class="token operator">=</span> <span class="token function">fun7</span><span class="token punctuation">(</span>TNode<span class="token operator">-></span>right<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        ret_val <span class="token operator">=</span> ret_val <span class="token operator">+</span> ret_val <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ret_val<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用非goto:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fun7</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>         <span class="token keyword">return</span> <span class="token number">0xffffffff</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-></span>data <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-></span>data <span class="token operator">&lt;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token function">fun7</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token function">fun7</span><span class="token punctuation">(</span>TNode<span class="token operator">-></span>left<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，如果当前结点和传入的值相等，返回0；<br>如果大于传入的结点，访问左子树；<br>小于传入的值，访问右子树。<br>要使最终的返回值为2，应该这样走：root -&gt; left -&gt; right<br>此时的结点值为0x16(22)</p><h3 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h3><blockquote><p>22</p></blockquote><p><img src="pic20.png" alt="完成"></p><h2 id="实验小结"><a href="#实验小结" class="headerlink" title="实验小结"></a>实验小结</h2><p>通过Bomb Lab实验，我学会了使用gdb调试工具，而且对机器指令有了更深的理解。通过GDB调试工具的使用，我也进一步理解了栈帧空间的框架，和原理。对函数调用，参数传递有了进一步的认识！</p><p>Total Time: 14h</p>]]></content>
      
      
      <categories>
          
          <category> CS实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组成原理 </tag>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串的模式匹配KMP</title>
      <link href="/2020/12/31/kmp/"/>
      <url>/2020/12/31/kmp/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>模式匹配是指从原字符串中寻找模式串。<br>按照暴力匹配的方法，每次出现失配的情况，模式串的匹配都会从头开始，但是这是很低效的。而KMP算法会将模式串移动到最优位置进行匹配。如下图：<br><img src="pic1.png" alt="暴力匹配与KMP对比"><br>本文将说明下标从“1”开始的KMP算法。</p><h2 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h2><p>模式串匹配过程中，需要移动的只有模式串。下面我们深入分析模式串：<br>当匹配发生失配时，我们不需要回溯到模式串的开头，而是<strong>将模式串相等的前缀移动到相等的后缀位置上</strong>，如下图：<br><img src="pic2.png" alt="移动模式串"><br>我们定义一个数组next[]，其中next[i]表示使子串s[1..i-1]的前缀s[1…k-1]等于后缀s[i-k+1…i-1]的最大的k（前缀跟后缀可以部分重叠，但不能是s[1..i-1]本身）；如果找不到相等的前后缀，就令next[i] = 1。<br>简单来说：<strong>next[i]就是s[1…i-1]最长相等前后缀 + 1</strong>。<br><strong>next[j]是第j位失配后重新开始匹配的位置。</strong><br>其中next[1]=0恒定。</p><h3 id="计算next数组"><a href="#计算next数组" class="headerlink" title="计算next数组"></a>计算next数组</h3><p>我们以模式串“abaabcac”为例：<br><img src="pic3.png" alt></p><h4 id="1-计算next-1"><a href="#1-计算next-1" class="headerlink" title="1.计算next[1]:"></a>1.计算next[1]:</h4><p>当第一位失配时，模式串应该向后滑动一位，即j指向0，开始下一轮的匹配<br><img src="pic4.png" alt></p><h4 id="2-计算next-2"><a href="#2-计算next-2" class="headerlink" title="2.计算next[2]:"></a>2.计算next[2]:</h4><p>第二位失配时，s[1…1]的最长前后缀为1，但是最长相等前后缀不能是串本身，所以最长前后缀为0。next[2]=0+1=1<br><img src="pic5.png" alt></p><h4 id="3-计算next-3"><a href="#3-计算next-3" class="headerlink" title="3.计算next[3]:"></a>3.计算next[3]:</h4><p>和next[2]一样，最长相等前后缀为0。<br><img src="pic6.png" alt></p><h4 id="4-计算next-4"><a href="#4-计算next-4" class="headerlink" title="4.计算next[4]"></a>4.计算next[4]</h4><p>4号位前的串为”aba”，它含有相等前后缀”a”，所有next[4]为串长（1）+1=2.<br><img src="pic7.png" alt></p><h4 id="5-计算next-5"><a href="#5-计算next-5" class="headerlink" title="5.计算next[5]"></a>5.计算next[5]</h4><p>5号位前的串为”abaa”，它含有相等前后缀”a”，所有next[5]为串长（1）+1=2.<br><img src="pic8.png" alt></p><h4 id="6-计算next-6"><a href="#6-计算next-6" class="headerlink" title="6.计算next[6]"></a>6.计算next[6]</h4><p>6号位前的串为”abaab”，它含有相等前后缀”ab”，所有next[6]为串长（2）+1=3.<br><img src="pic9.png" alt></p><h4 id="next数组值"><a href="#next数组值" class="headerlink" title="next数组值"></a>next数组值</h4><p>剩下的计算过程省略，我们得到最终的next数组：<br><img src="pic10.png" alt></p><h2 id="nextval数组"><a href="#nextval数组" class="headerlink" title="nextval数组"></a>nextval数组</h2><p>next数组还可以进行优化。比如模式串为”aaaab”时：<br>当在第四位的’a’失配时，重新匹配的next[4]=3仍然为’a’，仍然失败<br><img src="pic11.png" alt><br>于是我们引入新的数组nextval，存储优化后失配时重新开始匹配的位置。</p><h3 id="计算nextval"><a href="#计算nextval" class="headerlink" title="计算nextval"></a>计算nextval</h3><p>设我们已经求得串s的next数组，nextval数组的计算规则如下：<br>nextval[1] = 0<br>当 j &gt; 1 时</p><blockquote><ol><li><strong>若s[j] == s[next[j]]</strong><br>这说明从next[j]开始重新匹配仍然是失败的，所以另nextval[j] = nextval[next[j]]</li><li><strong>若s[j] != s[next[j]]</strong><br>这说明从next[j]开始重新匹配可能成功，所以另nextval[j] = next[j]</li></ol></blockquote><p>具体计算过程省略，下图给出了模式串“abaabcac”的nextval值：<br><img src="pic12.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后缀表达式</title>
      <link href="/2020/12/30/postfix-notation/"/>
      <url>/2020/12/30/postfix-notation/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>生活中，我们常用的数学表达式<em>a + b</em>称为中缀表达式——运算符在两个数字中间，但是计算机处理中缀表达式的效率很低。举个例子：</p><blockquote><p>表达式：a + b <code>*</code> c + d<br>由于计算机是从左向右扫描表达式，根据运算法则，第一次扫描执行b <code>*</code> c，然后再扫描一次把结果与a相加，最后一次扫描将b相加。<br>一共扫描了三次才计算出结果，这是十分低效的！</p></blockquote><p>更高效的做法是将表达式转换为后缀或前缀表达式。比如后缀表达式”<em>a b +</em>“就相当于中缀表达式”<em>a + b</em>“。<br>下面将介绍如何利用栈将中缀表达式转换为后缀表达式。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>设置一个栈用于存放运算符，初始为空。</p><h3 id="步骤一：从左到右扫描表达式，对于扫描到的内容进行如下操作："><a href="#步骤一：从左到右扫描表达式，对于扫描到的内容进行如下操作：" class="headerlink" title="步骤一：从左到右扫描表达式，对于扫描到的内容进行如下操作："></a>步骤一：从左到右扫描表达式，对于扫描到的内容进行如下操作：</h3><p><strong>1.扫描到的为数字</strong><br>直接将数字输出<br><strong>2.扫描到的为运算符</strong><br><strong>情况一</strong>： 若扫描到的运算符的优先级高于栈顶运算符（或栈为空），将运算符入栈。<br><strong>情况二</strong>： 扫描到的运算符优先级低于或等于栈内运算符，将栈顶所有优先级大于等于它的运算符出栈（如果遇到括号则停止出栈），然后将当前运算符入栈。<br><strong>3.若扫描到的为左括号”(“</strong><br>将左括号”(“入栈<br><strong>4.若扫描到的为右括号”)”</strong><br>将栈内运算符全部出栈，直到遇到左括号”(“</p><h3 id="步骤二：扫描完成后，栈内仍剩余运算符"><a href="#步骤二：扫描完成后，栈内仍剩余运算符" class="headerlink" title="步骤二：扫描完成后，栈内仍剩余运算符"></a>步骤二：扫描完成后，栈内仍剩余运算符</h3><p>将栈内所有运算符依次出栈输出。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img src="pic1.png" alt="表达式转换"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环队列</title>
      <link href="/2020/12/30/circular-queue/"/>
      <url>/2020/12/30/circular-queue/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>由于队列“队首出队，队尾入队”的特点，固定大小的顺序队列会出现“假溢出”的情况——存储区还未满，但队列却显示溢出。循环队列的出现解决了假溢出问题。<br><img src="pic1.png" alt="假溢出"></p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>由于队列有元素出列，front就向后移动，所以队列前面的空间就空了出来。为了更合理的利用空间，人们想了一个办法：将队列的首尾相连接。这样当rear移动到MAXSIZE时，会再从0开始循环。那当什么时候队列满呢？当rear等于front的时候。可是队列为空的时候也是同样的条件，那不就没法判断了吗？又有人提出了这样的想法：牺牲一个存储空间，front前面不存数据，当rear在front前面的时候就是满了，如图<br><img src="pic2.png" alt="循环队列"><br><strong>front指针</strong>：指向队首元素<br><strong>rear指针</strong>：指向入队元素要插入的位置<br><strong>队空条件</strong>：rear == front<br><strong>队满条件</strong>：（rear + 1）% MAXSIZE == front</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>基本操作有：入队、出队<br>假设MAXSIZE为循环队列存储空间大小</p><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><p>先判断是否队满，然后入队（先插入元素，然后rear指针+1，再取模）。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>rear <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAXSIZE <span class="token operator">==</span> front<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"The Queue is full."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    data<span class="token punctuation">[</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>    rear <span class="token operator">=</span> <span class="token punctuation">(</span>rear <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAXSIZE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><p>先判断是否队空，然后front指针+1， 再取模。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rear <span class="token operator">==</span> front<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Empty Queue!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> ret_val <span class="token operator">=</span> data<span class="token punctuation">[</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>    front <span class="token operator">=</span> <span class="token punctuation">(</span>front <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAXSIZE<span class="token punctuation">;</span>    <span class="token keyword">return</span> ret_val<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h2><p>c++面向对象忘记怎么写了，写得很烂~</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">ifndef</span> CIRCULAR_QUEUE_H</span><span class="token macro property">#<span class="token directive keyword">define</span> CIRCULAR_QUEUE_H</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> MAXSIZE <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">CircularQueue</span> <span class="token punctuation">{</span>   <span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> front<span class="token punctuation">;</span>    <span class="token keyword">int</span> rear<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> data<span class="token punctuation">;</span>   <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">CircularQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">CircularQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>rear <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAXSIZE <span class="token operator">==</span> front<span class="token punctuation">)</span> <span class="token punctuation">{</span>            std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"The Queue is full."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        data<span class="token punctuation">[</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>        rear <span class="token operator">=</span> <span class="token punctuation">(</span>rear <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAXSIZE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">get_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rear <span class="token operator">==</span> front<span class="token punctuation">)</span> <span class="token punctuation">{</span>            std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Empty Queue!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> data<span class="token punctuation">[</span>rear<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rear <span class="token operator">==</span> front<span class="token punctuation">)</span> <span class="token punctuation">{</span>            std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Empty Queue!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> ret_val <span class="token operator">=</span> data<span class="token punctuation">[</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>        front <span class="token operator">=</span> <span class="token punctuation">(</span>front <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAXSIZE<span class="token punctuation">;</span>        <span class="token keyword">return</span> ret_val<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>CircularQueue<span class="token operator">::</span><span class="token function">CircularQueue</span><span class="token punctuation">(</span><span class="token comment" spellcheck="true">/* args */</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    front <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    rear <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>CircularQueue<span class="token operator">::</span><span class="token operator">~</span><span class="token function">CircularQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">delete</span> data<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表(未完待续~)</title>
      <link href="/2020/12/30/linked-list/"/>
      <url>/2020/12/30/linked-list/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>线性表和链表是两种基本的数据结构，他们各有各的优势。<br><strong>线性表的优点</strong>：可以随机存取、存储密度高。<br><strong>链表的优点</strong>：插入和删除操作不需要移动元素、可以动态分配存储空间。</p><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h3 id="一、组成"><a href="#一、组成" class="headerlink" title="一、组成"></a>一、组成</h3><p><strong>数据域 + 指针域</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> LNode<span class="token punctuation">{</span>    ElemType data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> LNode <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span>LNode<span class="token punctuation">,</span> <span class="token operator">*</span>LinkList<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、几个概念"><a href="#二、几个概念" class="headerlink" title="二、几个概念"></a>二、几个概念</h3><p><strong>头结点</strong>：在第一个结点（首元结点）前附设的一个结点。其指针域指向第一个结点，数据域可以存储链表长度等附加信息。<br><img src="pic1.jpg" alt="带头结点的链表"><br><strong>首元结点</strong>：存储第一个元素的结点。如上图的”HELLO”结点。<br><strong>头指针</strong>：指向链表第一个结点（若有头结点，则为头结点）的指针。</p><h3 id="三、基本操作"><a href="#三、基本操作" class="headerlink" title="三、基本操作"></a>三、基本操作</h3><p>链表的基本操作有：查找、插入、删除等</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>链表的插入</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法分析(未完待续~)</title>
      <link href="/2020/12/30/growth-of-function/"/>
      <url>/2020/12/30/growth-of-function/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2>]]></content>
      
      
      <categories>
          
          <category> 数据结构复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯经验分享</title>
      <link href="/2020/12/28/lanqiao-prepare/"/>
      <url>/2020/12/28/lanqiao-prepare/</url>
      
        <content type="html"><![CDATA[<p>比赛结束都快两个月了，总算想起来写这篇博客，害。</p><h2 id="获奖经历"><a href="#获奖经历" class="headerlink" title="获奖经历"></a>获奖经历</h2><p>十一届蓝桥杯软件类（国赛） 三等奖</p><h2 id="为什么参加蓝桥杯？"><a href="#为什么参加蓝桥杯？" class="headerlink" title="为什么参加蓝桥杯？"></a>为什么参加蓝桥杯？</h2><p>一方面想证明自己，另一方面也为了在大学里有个奔头。<br>大一，我进入了一个我不是很感兴趣的专业——电子信息工程。这个专业太偏硬件了，而我喜欢编程更多一点，所以决心转到计算机学院（当时，选择转软件工程的主要原因是为了逃离数电、模电）。转专业也不是说转就能转的，我总得拿出点实力证明吧。<strong>于是我去知乎上搜索计算机相关竞赛，发现蓝桥杯是个不错的选择</strong>。正巧那个时候学校正在开展蓝桥杯校赛，我就去报名试试。<br>刚进入大学，我也不清楚自己想要干什么，大学四年该怎么过。蓝桥杯给了我一点方向，至少让我在短期有了一个目标————准备比赛。</p><h2 id="比赛收获"><a href="#比赛收获" class="headerlink" title="比赛收获"></a>比赛收获</h2><p>蓝桥杯的收获主要是在备赛过程中学习了算法。数据结构相关的知识，也提高了自己的编程能力。而且，数据结构和算法有了一定基础后，大二的数据结构、算法设计等专业课就会上得比较轻松。</p><h2 id="备赛"><a href="#备赛" class="headerlink" title="备赛"></a>备赛</h2><p>备赛主要是<strong>学算法 + 刷题</strong>，学完一个算法就去找相关的题目练习，巩固知识。<br>算法的学习由浅入深，可以先从排序开始，然后<strong>深度优先搜索</strong>等。</p><h3 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h3><p>《算法笔记》：<a href="https://item.jd.com/12769375.html" target="_blank" rel="noopener">京东购买</a><br>这本书的难度适中。第一部分帮助我们复习C语言基础，还有一点点C++ STL的使用的教程，这样可以更快地上手写代码。算法部分包括<strong>算法</strong>和<strong>数据结构</strong>，用比较生动的例子帮助我们理解算法。这本书的算法涵盖了省赛的大部分考点（也有些算法省赛不会涉及）。</p><h3 id="Online-Judge推荐"><a href="#Online-Judge推荐" class="headerlink" title="Online Judge推荐"></a>Online Judge推荐</h3><ol><li>HDU：2000 ~ 2099 <a href="http://acm.hdu.edu.cn/listproblem.php?vol=11" target="_blank" rel="noopener">链接</a></li><li>LeetCode：每日一题 <a href="https://leetcode-cn.com/problemset/all/" target="_blank" rel="noopener">链接</a><br>这个可以用来保持手感，不过这个OJ只需要写函数，不用写全部的代码。</li></ol><p><strong>PS：Online Judge 最好不要按照题号顺序刷，最后按照算法题型来写，这样效率更高</strong></p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>荷兰国旗问题</title>
      <link href="/2020/12/26/holland-flag/"/>
      <url>/2020/12/26/holland-flag/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>现有n各红白蓝三种不同颜色的小球，乱序排列在一起，请通过两两交换任意两个小球，使得从左至右，依次是一些红球、一些白球、一些蓝球。<br>红白蓝分别编号为0、1、2<br>LeetCode:<a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-colors/</a></p><h2 id="分析与解法"><a href="#分析与解法" class="headerlink" title="分析与解法"></a>分析与解法</h2><p>这个问题类似于排序，目标是将乱序的数组排序，划分为0、1、2三部分。<br>因为一共只有三个部分，只要前面的部分（1）和后面的部分（2）划分好，中间部分（1）就自然出来了。<br>利用三指针，我们可以经过一趟扫描就实现。时间复杂度O（n）</p><h3 id="三指针"><a href="#三指针" class="headerlink" title="三指针"></a>三指针</h3><p><img src="img1.png" alt="三指针"><br>我们设三个指针：begin、current、end，其中：<br>begin指针以前的数都是0。<br>current指针指向当前待排序的数，begin和current之间的数为1。<br>end指针之后的数都是2.<br>初始状态下：begin和current都指向第一个元素（下标0），end指向最后一个元素（下标n-1）。<br>下面我开始对数组进行扫描：<br>每一次我们判断current指向的数。</p><h4 id="1-current指向的数为0"><a href="#1-current指向的数为0" class="headerlink" title="1. current指向的数为0"></a>1. current指向的数为0</h4><p>0是属于前面的部分，他应该在begin指针之前。所以我们要将0移入第一部分，并将begin、current指针后移：</p><pre class="line-numbers language-C++"><code class="language-C++">swap(colors[begin], colors[end]);begin++;current++;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2-current指向的数为1"><a href="#2-current指向的数为1" class="headerlink" title="2. current指向的数为1"></a>2. current指向的数为1</h4><p>因为1是在begin和current之间，所以只需要将current后移就行，不需要交换操作。</p><h4 id="3-current指向的数为2"><a href="#3-current指向的数为2" class="headerlink" title="3. current指向的数为2"></a>3. current指向的数为2</h4><p>2属于最后的部分，它应该位于end指针之后。<br>现在我们<strong>交换current和end指针指向的数</strong>，再将<strong>end指针前移</strong>，就完成了插入。<br>那current需要后移吗？<br><strong>不需要！</strong>原先end指针指向的数可能是1，也可能是0。如果为0的话，current后移会使中间部分无序。</p><pre class="line-numbers language-C++"><code class="language-C++">swap(colors[current], colors[end]);end--;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//完整C++</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> MAXN <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span><span class="token keyword">int</span> colors<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Partition the array into three sections: all-0, all-1, all-2  * */</span><span class="token keyword">void</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//Let begin point to the first element, and end point to the last element.</span>    <span class="token keyword">int</span> begin <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> current <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> end <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>current <span class="token operator">&lt;=</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>colors<span class="token punctuation">[</span>current<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>colors<span class="token punctuation">[</span>current<span class="token punctuation">]</span><span class="token punctuation">,</span> colors<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            begin<span class="token operator">++</span><span class="token punctuation">;</span>            current<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>colors<span class="token punctuation">[</span>current<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>colors<span class="token punctuation">[</span>current<span class="token punctuation">]</span><span class="token punctuation">,</span> colors<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            end<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            current<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cin <span class="token operator">>></span> colors<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">partition</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> colors<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//LeetCode</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">sortColors</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> begin <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cur <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> end <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">&lt;=</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                begin<span class="token operator">++</span><span class="token punctuation">;</span>                cur<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                cur<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                end<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法整理汇总（附代码）</title>
      <link href="/2020/02/16/sort-algorithms/"/>
      <url>/2020/02/16/sort-algorithms/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文整理并总结了十大经典的排序算法（冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序、计数排序、基数排序、桶排序、堆排序）的时间复杂度、空间复杂度等性质。</p><p><strong>本文并不会详细讲解每种排序算法的原理</strong>，网上有很多很好的教程，大家可以自己去搜了看。</p><p>最后我还亲自手写了十种排序算法的 c++ 代码，大家可以用来通过 <a href="https://leetcode-cn.com/problems/sort-an-array/" title="LeetCode 912. 排序数组" target="_blank" rel="noopener">LeetCode 912. 排序数组</a> 这道题。</p><h2 id="性质汇总"><a href="#性质汇总" class="headerlink" title="性质汇总"></a>性质汇总</h2><blockquote><p>如果发现表中有错误，请留言告知。</p></blockquote><table><thead><tr><th>算法</th><th>最好</th><th>最坏</th><th>平均</th><th>空间</th><th align="center">稳定性</th><th align="center">是否基于比较</th></tr></thead><tbody><tr><td>冒泡排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>选择排序</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>插入排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>快速排序</td><td>$O(n\log n)$</td><td>$O(n^2)$</td><td>$O(n\log n)$</td><td>$O(\log n)$~$O(n)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>归并排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>希尔排序</td><td>$O(n^{1.3})$</td><td>$O(n^2)$</td><td>$O(n\log n)$~$O(n^2)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>计数排序</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>基数排序</td><td>$O(nk)$</td><td>$O(nk)$</td><td>$O(nk)$</td><td>$O(n+k)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>桶排序</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n+m)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>堆排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr></tbody></table><blockquote><p>如果表格显示有问题的话，还可以直接看下面的汇总图：</p></blockquote><p><img src="1.png" alt="十大经典排序算法性质汇总"></p><h3 id="维基百科"><a href="#维基百科" class="headerlink" title="维基百科"></a>维基百科</h3><p>我觉得还是英文维基百科讲的比较详细、严谨。如果大家看的比较累的话，可以自己百度搜索相应的教程。</p><p><strong>冒泡排序</strong><br><a href="https://en.wikipedia.org/wiki/Bubble_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bubble_sort</a></p><p><strong>选择排序</strong><br><a href="https://en.wikipedia.org/wiki/Selection_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Selection_sort</a></p><p><strong>插入排序</strong><br><a href="https://en.wikipedia.org/wiki/Insertion_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Insertion_sort</a></p><p><strong>快速排序</strong><br><a href="https://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Quicksort</a></p><p><strong>归并排序</strong><br><a href="https://en.wikipedia.org/wiki/Merge_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Merge_sort</a></p><p><strong>希尔排序</strong><br><a href="https://en.wikipedia.org/wiki/Shellsort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Shellsort</a></p><p><strong>计数排序</strong><br><a href="https://en.wikipedia.org/wiki/Counting_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Counting_sort</a></p><p><strong>基数排序</strong><br><a href="https://en.wikipedia.org/wiki/Radix_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Radix_sort</a></p><p><strong>桶排序</strong><br><a href="https://en.wikipedia.org/wiki/Bucket_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bucket_sort</a></p><p><strong>堆排序</strong><br><a href="https://en.wikipedia.org/wiki/Heapsort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Heapsort</a></p><h2 id="排序算法可视化"><a href="#排序算法可视化" class="headerlink" title="排序算法可视化"></a>排序算法可视化</h2><p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>所有的排序算法接口都是相同的，也就是 <code>vector&lt;int&gt; xxxSort(vector&lt;int&gt;&amp; nums)</code> 。只需要你传入一个 <code>vector&lt;int&gt;</code> 类型的数组，就能返回排序后的结果。</p><p>运行下来可以发现，桶排序速度是比较快的。而冒泡排序、选择排序和插入排序因为时间复杂度太高无法通过本题，基数排序因为无法处理负数也不能通过本题。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sortArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 冒泡排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n<span class="token number">-2</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> i<span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 选择排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">selectSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    idx <span class="token operator">=</span> j<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 插入排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">insertSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 快速排序（24 ms）</span>    <span class="token keyword">void</span> <span class="token function">qSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">quickSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 归并排序（192 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lnums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> rnums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token operator">-</span>l <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token operator">-</span>m<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rnums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>rnums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token operator">-</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token operator">-</span>m<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>rnums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 归并排序 + 非递归（80 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mergeSortNR</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> len <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> len <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> n<span class="token operator">-</span>len<span class="token punctuation">;</span> l <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>len<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token operator">+</span>len<span class="token number">-1</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> l<span class="token operator">+</span><span class="token number">2</span><span class="token operator">*</span>len<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>                <span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">,</span> j <span class="token operator">=</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">[</span>i<span class="token operator">-</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 希尔排序（40 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">shellSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> gap <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> gap <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j<span class="token operator">-</span>gap <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token operator">-</span>gap<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">-</span><span class="token operator">=</span> gap<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">-</span>gap<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 计数排序（32 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">countSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">min_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> maxv<span class="token operator">-</span>minv<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>minv<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token operator">+</span>minv<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 基数排序（不适用于负数）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">radixSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>maxv <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxv <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>            maxd<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rank</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> base <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>maxd <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>base<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> count<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                rank<span class="token punctuation">[</span><span class="token operator">--</span>count<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>base<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            maxd<span class="token operator">--</span><span class="token punctuation">;</span>            base <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 桶排序 (20 ms)</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">bucketSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">min_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> bs <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>maxv<span class="token operator">-</span>minv<span class="token punctuation">)</span><span class="token operator">/</span>bs<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">bucket</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            bucket<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>minv<span class="token punctuation">)</span><span class="token operator">/</span>bs<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> sz <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 堆排序（32 ms）</span>    <span class="token keyword">void</span> <span class="token function">adjust</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> c1 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c2 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token punctuation">(</span>c2<span class="token operator">&lt;</span>s <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>c2<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>c1<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> c2 <span class="token operator">:</span> c1<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> c<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">heapSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
